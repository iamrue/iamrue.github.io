---
layout: post
title:  "포인터 (기초)"
---
  
1. 포인터 이론 (* Asterisk)  
 (1) 포인터의 선언  데이터타입 * 포인터변수이름;  
    - ex) int var2=3; 
          int * var1 = <u>&var2</u>; -> 
          **var1은int형 테이터를 가진 var2의 메모리 주소를 저장한다.** 
    - <u>이 상황을 var1이 var2를 참조한다고 말한다.</u>  
    - var1 은 var2의 메모리주소 별명  
          
       
   (2) 포인터의 데이터 형식문자  
    - 메모리 주소를 출력하기 위한 형식 문자는 **%p** 이다.  
       
   (3) 예시의 데이터 메모리 상황  
      - | R  |      AM        |  
         |var2|       3        |  
         |var1|var2의 메모리주소|    
         
 (4)주의 사항  
  - 실제로 메모리 주소를 출력하면 계속 바뀐다 왜냐하면 컴퓨터는 메모리 공간을 임의로 할당하기 때문이다.  
  - 포인터를 선언할 때 당연히 값이 없는 변수도 사용가능하다. 포인터는 값이 아니라<u>공간</u>이 중요하다.   
  - 아래 식에서 ptr1, ptr2는 똑같이 num을 참조한다. 다수의 포인터 변수가 같은 메모리 주소를 참조 할 수 있다.
          
              int num;
              int ptr1 =&num;
              int ptr2 =ptr1;  
          
- 아래 코드를 출력할때 값은 똑같이 나온다. (변수와 포인터 변수로 메모리 출력하는 방법)
          
              double A =3;
              double *a = &A;
              prinf("%p",&A);
              printf("%p",a);    
              
- 메모리 주소를 저장한 변수의 메모리 주소를 저장하는 것은 더블 asterisk 이므로 불가능하다.(아래식)  
             
              int num =10;
              int*ptr1 =&num;
              int*ptr2= &ptr; //불가능    
           
(5)포인터의 역참조  
  - 포인터 변수를 이용해서 메모리주소의 변수 값을 참조할 수 있다.  
  - 형태: <u>*포인터변수</u>  
  - ex) 
          
              int num =10;
              int*ptr1= &num;              
              printf("num의 값은 =%d",*ptr1); //둘 다 10이 출력됨   
              printf("num의 값은 =%d",num);
              
             
